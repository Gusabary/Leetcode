# Weekly Contest 176

## P1

## P2

## P3

贪心，有点 Earliest Deadline First 的感觉，问题出在排序上，我的策略是按照结束时间排序，一开始手写选排，超时了，想起之前学习的 stl sort，但是由于我是按照结束时间排序，所以用不了默认的比较函数，于是手写了一个比较函数作为 sort 的第三个参数，但是 leetcode 执行的时候就是有问题 md，再然后又想起之前自己手写过快排，改了一下拿过来用还是超时。经过一番测试，发现显然选排最慢，自己手写的快排其次，stl sort 确实快（默认比较函数）

结束后看了看别人的代码，发现完全不用按结束时间排序，其实可以按照开始时间排序，这样就可以用默认的比较函数了。另外还有别的方法，比如新开一个 vector，起始时间作为下标，结束时间作为值（值也是一个 vector）中的一个元素，这样处理后就可以得到有序的数据了。

而且，非要用自定义的比较函数也不是不可以，可以写成这样 leetcode 执行就没问题了：

```c++
sort(events.begin(), events.end(), [](vector<int>& v1, vector<int>& v2) {
    return v1[1]==v2[1] ? v1[0]<v2[0] : v1[1]<v2[1];
});
```

就是直接把函数实现写在第三个参数里面。

## P4

罕见地不是动规，不过其实不难，想到就是想到了

从目标往前推，每次拿最大的元素减去其余所有元素，如此循环，如果最后能还原成全 1 的数组，返回 true，否则返回 false

`f[i]` 表示跳到第 i 个位置时已跳过的数量，可以从左右各 d 的范围内转移过来，+1.

但是烦就烦在起点不固定。一开始我以每个位置作为起点分别求一遍，但是太慢了，后来我就以当前没访问过的最高的位置作为起点，快了很多，但还是不够。瓶颈变成了状态转移的时候我是一遍一遍扫的，进行了对很多重复位置的判断，实际上每次只用判断那些新访问的位置。可以优化成从已访问过的位置出发，不断向外拓展。

##### Last-modified date: 2020.2.16, 12 p.m.