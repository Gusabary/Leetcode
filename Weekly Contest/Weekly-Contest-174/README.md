# Weekly Contest 174

## P1

## P2

一个有用的知识：对 `vector` 排序可以直接用 `sort`：

```c++
vector<int> data;
sort(data.begin(), data.end(), greater<int>());
```

`sort` 默认是升序排列，如果指定了第三个参数（排序用的函数），则排完的结果两两之间满足该函数的约束。

## P3

后序遍历，将以某节点为根形成的子树中所有节点的值的和作为该节点的值填入该节点，最终只要判断哪一个节点的值最接近根节点值的一半，就将那个节点的子树分离出去，这样分离出的子树和剩下的子树乘积最大。

还有一个值得一提的地方就是要求返回两个大整数相乘后模一个数的结果，可以用一个循环，比如 a*b，就循环 b 次，每次加 a 取模，这样就不会溢出了。

## P4

动规

`f[i]` 表示跳到第 i 个位置时已跳过的数量，可以从左右各 d 的范围内转移过来，+1.

但是烦就烦在起点不固定。一开始我以每个位置作为起点分别求一遍，但是太慢了，后来我就以当前没访问过的最高的位置作为起点，快了很多，但还是不够。瓶颈变成了状态转移的时候我是一遍一遍扫的，进行了对很多重复位置的判断，实际上每次只用判断那些新访问的位置。可以优化成从已访问过的位置出发，不断向外拓展。

##### Last-modified date: 2020.2.16, 12 p.m.